// Autogenerated on: 2013-07-01 13:55:38 +0200
#include "nwnx_redis_core"

/**
 * APPEND
 *
 * Append a value to a key
 *
 * Time complexity: O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.
 */
string APPEND(string key, string value);

/**
 * AUTH
 *
 * Authenticate to the server
 */
string AUTH(string password);

/**
 * BGREWRITEAOF
 *
 * Asynchronously rewrite the append-only file
 */
string BGREWRITEAOF();

/**
 * BGSAVE
 *
 * Asynchronously save the dataset to disk
 */
string BGSAVE();

/**
 * BITCOUNT
 *
 * Count set bits in a string
 *
 * Time complexity: O(N)
 */
string BITCOUNT(string key, string start = "", string end = "");

/**
 * BITOP
 *
 * Perform bitwise operations between strings
 *
 * Time complexity: O(N)
 */
string BITOP(string operation, string destkey, string key);

/**
 * BLPOP
 *
 * Remove and get the first element in a list, or block until one is available
 *
 * Time complexity: O(1)
 */
string BLPOP(string key, string timeout);

/**
 * BRPOP
 *
 * Remove and get the last element in a list, or block until one is available
 *
 * Time complexity: O(1)
 */
string BRPOP(string key, string timeout);

/**
 * BRPOPLPUSH
 *
 * Pop a value from a list, push it to another list and return it; or block until one is available
 *
 * Time complexity: O(1)
 */
string BRPOPLPUSH(string source, string destination, string timeout);

/**
 * CLIENT KILL
 *
 * Kill the connection of a client
 *
 * Time complexity: O(N) where N is the number of client connections
 */
string CLIENT_KILL(string ip_port);

/**
 * CLIENT LIST
 *
 * Get the list of client connections
 *
 * Time complexity: O(N) where N is the number of client connections
 */
string CLIENT_LIST();

/**
 * CLIENT GETNAME
 *
 * Get the current connection name
 *
 * Time complexity: O(1)
 */
string CLIENT_GETNAME();

/**
 * CLIENT SETNAME
 *
 * Set the current connection name
 *
 * Time complexity: O(1)
 */
string CLIENT_SETNAME(string connection_name);

/**
 * CONFIG GET
 *
 * Get the value of a configuration parameter
 */
string CONFIG_GET(string parameter);

/**
 * CONFIG SET
 *
 * Set a configuration parameter to the given value
 */
string CONFIG_SET(string parameter, string value);

/**
 * CONFIG RESETSTAT
 *
 * Reset the stats returned by INFO
 *
 * Time complexity: O(1)
 */
string CONFIG_RESETSTAT();

/**
 * DBSIZE
 *
 * Return the number of keys in the selected database
 */
string DBSIZE();

/**
 * DEBUG OBJECT
 *
 * Get debugging information about a key
 */
string DEBUG_OBJECT(string key);

/**
 * DEBUG SEGFAULT
 *
 * Make the server crash
 */
string DEBUG_SEGFAULT();

/**
 * DECR
 *
 * Decrement the integer value of a key by one
 *
 * Time complexity: O(1)
 */
string DECR(string key);

/**
 * DECRBY
 *
 * Decrement the integer value of a key by the given number
 *
 * Time complexity: O(1)
 */
string DECRBY(string key, string decrement);

/**
 * DEL
 *
 * Delete a key
 *
 * Time complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).
 */
string DEL(string key);

/**
 * DISCARD
 *
 * Discard all commands issued after MULTI
 */
string DISCARD();

/**
 * DUMP
 *
 * Return a serialized version of the value stored at the specified key.
 *
 * Time complexity: O(1) to access the key and additional O(N*M) to serialized it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).
 */
string DUMP(string key);

/**
 * ECHO
 *
 * Echo the given string
 */
string ECHO(string message);

/**
 * EVAL
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 */
string EVAL(string script, string numkeys, string key, string arg);

/**
 * EVALSHA
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 */
string EVALSHA(string sha1, string numkeys, string key, string arg);

/**
 * EXEC
 *
 * Execute all commands issued after MULTI
 */
string EXEC();

/**
 * EXISTS
 *
 * Determine if a key exists
 *
 * Time complexity: O(1)
 */
string EXISTS(string key);

/**
 * EXPIRE
 *
 * Set a key's time to live in seconds
 *
 * Time complexity: O(1)
 */
string EXPIRE(string key, string seconds);

/**
 * EXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp
 *
 * Time complexity: O(1)
 */
string EXPIREAT(string key, string timestamp);

/**
 * FLUSHALL
 *
 * Remove all keys from all databases
 */
string FLUSHALL();

/**
 * FLUSHDB
 *
 * Remove all keys from the current database
 */
string FLUSHDB();

/**
 * GET
 *
 * Get the value of a key
 *
 * Time complexity: O(1)
 */
string GET(string key);

/**
 * GETBIT
 *
 * Returns the bit value at offset in the string value stored at key
 *
 * Time complexity: O(1)
 */
string GETBIT(string key, string offset);

/**
 * GETRANGE
 *
 * Get a substring of the string stored at a key
 *
 * Time complexity: O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.
 */
string GETRANGE(string key, string start, string end);

/**
 * GETSET
 *
 * Set the string value of a key and return its old value
 *
 * Time complexity: O(1)
 */
string GETSET(string key, string value);

/**
 * HDEL
 *
 * Delete one or more hash fields
 *
 * Time complexity: O(N) where N is the number of fields to be removed.
 */
string HDEL(string key, string field);

/**
 * HEXISTS
 *
 * Determine if a hash field exists
 *
 * Time complexity: O(1)
 */
string HEXISTS(string key, string field);

/**
 * HGET
 *
 * Get the value of a hash field
 *
 * Time complexity: O(1)
 */
string HGET(string key, string field);

/**
 * HGETALL
 *
 * Get all the fields and values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 */
string HGETALL(string key);

/**
 * HINCRBY
 *
 * Increment the integer value of a hash field by the given number
 *
 * Time complexity: O(1)
 */
string HINCRBY(string key, string field, string increment);

/**
 * HINCRBYFLOAT
 *
 * Increment the float value of a hash field by the given amount
 *
 * Time complexity: O(1)
 */
string HINCRBYFLOAT(string key, string field, string increment);

/**
 * HKEYS
 *
 * Get all the fields in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 */
string HKEYS(string key);

/**
 * HLEN
 *
 * Get the number of fields in a hash
 *
 * Time complexity: O(1)
 */
string HLEN(string key);

/**
 * HMGET
 *
 * Get the values of all the given hash fields
 *
 * Time complexity: O(N) where N is the number of fields being requested.
 */
string HMGET(string key, string field);

/**
 * HMSET
 *
 * Set multiple hash fields to multiple values
 *
 * Time complexity: O(N) where N is the number of fields being set.
 */
string HMSET(string key, string field);

/**
 * HSET
 *
 * Set the string value of a hash field
 *
 * Time complexity: O(1)
 */
string HSET(string key, string field, string value);

/**
 * HSETNX
 *
 * Set the value of a hash field, only if the field does not exist
 *
 * Time complexity: O(1)
 */
string HSETNX(string key, string field, string value);

/**
 * HVALS
 *
 * Get all the values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 */
string HVALS(string key);

/**
 * INCR
 *
 * Increment the integer value of a key by one
 *
 * Time complexity: O(1)
 */
string INCR(string key);

/**
 * INCRBY
 *
 * Increment the integer value of a key by the given amount
 *
 * Time complexity: O(1)
 */
string INCRBY(string key, string increment);

/**
 * INCRBYFLOAT
 *
 * Increment the float value of a key by the given amount
 *
 * Time complexity: O(1)
 */
string INCRBYFLOAT(string key, string increment);

/**
 * INFO
 *
 * Get information and statistics about the server
 */
string INFO(string section = "");

/**
 * KEYS
 *
 * Find all keys matching the given pattern
 *
 * Time complexity: O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.
 */
string KEYS(string pattern);

/**
 * LASTSAVE
 *
 * Get the UNIX time stamp of the last successful save to disk
 */
string LASTSAVE();

/**
 * LINDEX
 *
 * Get an element from a list by its index
 *
 * Time complexity: O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1).
 */
string LINDEX(string key, string index);

/**
 * LINSERT
 *
 * Insert an element before or after another element in a list
 *
 * Time complexity: O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N).

 * - Valid values for where: "BEFORE", "AFTER"
 */
string LINSERT(string key, string where, string pivot, string value);

/**
 * LLEN
 *
 * Get the length of a list
 *
 * Time complexity: O(1)
 */
string LLEN(string key);

/**
 * LPOP
 *
 * Remove and get the first element in a list
 *
 * Time complexity: O(1)
 */
string LPOP(string key);

/**
 * LPUSH
 *
 * Prepend one or multiple values to a list
 *
 * Time complexity: O(1)
 */
string LPUSH(string key, string value);

/**
 * LPUSHX
 *
 * Prepend a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 */
string LPUSHX(string key, string value);

/**
 * LRANGE
 *
 * Get a range of elements from a list
 *
 * Time complexity: O(S+N) where S is the start offset and N is the number of elements in the specified range.
 */
string LRANGE(string key, string start, string stop);

/**
 * LREM
 *
 * Remove elements from a list
 *
 * Time complexity: O(N) where N is the length of the list.
 */
string LREM(string key, string count, string value);

/**
 * LSET
 *
 * Set the value of an element in a list by its index
 *
 * Time complexity: O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1).
 */
string LSET(string key, string index, string value);

/**
 * LTRIM
 *
 * Trim a list to the specified range
 *
 * Time complexity: O(N) where N is the number of elements to be removed by the operation.
 */
string LTRIM(string key, string start, string stop);

/**
 * MGET
 *
 * Get the values of all the given keys
 *
 * Time complexity: O(N) where N is the number of keys to retrieve.
 */
string MGET(string key);

/**
 * MIGRATE
 *
 * Atomically transfer a key from a Redis instance to another one.
 *
 * Time complexity: This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.
 */
string MIGRATE(string host, string port, string key, string destination_db, string timeout);

/**
 * MONITOR
 *
 * Listen for all requests received by the server in real time
 */
string MONITOR();

/**
 * MOVE
 *
 * Move a key to another database
 *
 * Time complexity: O(1)
 */
string MOVE(string key, string db);

/**
 * MSET
 *
 * Set multiple keys to multiple values
 *
 * Time complexity: O(N) where N is the number of keys to set.
 */
string MSET(string key);

/**
 * MSETNX
 *
 * Set multiple keys to multiple values, only if none of the keys exist
 *
 * Time complexity: O(N) where N is the number of keys to set.
 */
string MSETNX(string key);

/**
 * MULTI
 *
 * Mark the start of a transaction block
 */
string MULTI();

/**
 * OBJECT
 *
 * Inspect the internals of Redis objects
 *
 * Time complexity: O(1) for all the currently implemented subcommands.
 */
string OBJECT(string subcommand, string arguments = "");

/**
 * PERSIST
 *
 * Remove the expiration from a key
 *
 * Time complexity: O(1)
 */
string PERSIST(string key);

/**
 * PEXPIRE
 *
 * Set a key's time to live in milliseconds
 *
 * Time complexity: O(1)
 */
string PEXPIRE(string key, string milliseconds);

/**
 * PEXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp specified in milliseconds
 *
 * Time complexity: O(1)
 */
string PEXPIREAT(string key, string milliseconds_timestamp);

/**
 * PING
 *
 * Ping the server
 */
string PING();

/**
 * PSETEX
 *
 * Set the value and expiration in milliseconds of a key
 *
 * Time complexity: O(1)
 */
string PSETEX(string key, string milliseconds, string value);

/**
 * PTTL
 *
 * Get the time to live for a key in milliseconds
 *
 * Time complexity: O(1)
 */
string PTTL(string key);

/**
 * PUBLISH
 *
 * Post a message to a channel
 *
 * Time complexity: O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).
 */
string PUBLISH(string channel, string message);

/**
 * QUIT
 *
 * Close the connection
 */
string QUIT();

/**
 * RANDOMKEY
 *
 * Return a random key from the keyspace
 *
 * Time complexity: O(1)
 */
string RANDOMKEY();

/**
 * RENAME
 *
 * Rename a key
 *
 * Time complexity: O(1)
 */
string RENAME(string key, string newkey);

/**
 * RENAMENX
 *
 * Rename a key, only if the new key does not exist
 *
 * Time complexity: O(1)
 */
string RENAMENX(string key, string newkey);

/**
 * RESTORE
 *
 * Create a key using the provided serialized value, previously obtained using DUMP.
 *
 * Time complexity: O(1) to create the new key and additional O(N*M) to recostruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).
 */
string RESTORE(string key, string ttl, string serialized_value);

/**
 * RPOP
 *
 * Remove and get the last element in a list
 *
 * Time complexity: O(1)
 */
string RPOP(string key);

/**
 * RPOPLPUSH
 *
 * Remove the last element in a list, append it to another list and return it
 *
 * Time complexity: O(1)
 */
string RPOPLPUSH(string source, string destination);

/**
 * RPUSH
 *
 * Append one or multiple values to a list
 *
 * Time complexity: O(1)
 */
string RPUSH(string key, string value);

/**
 * RPUSHX
 *
 * Append a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 */
string RPUSHX(string key, string value);

/**
 * SADD
 *
 * Add one or more members to a set
 *
 * Time complexity: O(N) where N is the number of members to be added.
 */
string SADD(string key, string member);

/**
 * SAVE
 *
 * Synchronously save the dataset to disk
 */
string SAVE();

/**
 * SCARD
 *
 * Get the number of members in a set
 *
 * Time complexity: O(1)
 */
string SCARD(string key);

/**
 * SCRIPT EXISTS
 *
 * Check existence of scripts in the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts to check (so checking a single script is an O(1) operation).
 */
string SCRIPT_EXISTS(string script);

/**
 * SCRIPT FLUSH
 *
 * Remove all the scripts from the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts in cache
 */
string SCRIPT_FLUSH();

/**
 * SCRIPT KILL
 *
 * Kill the script currently in execution.
 *
 * Time complexity: O(1)
 */
string SCRIPT_KILL();

/**
 * SCRIPT LOAD
 *
 * Load the specified Lua script into the script cache.
 *
 * Time complexity: O(N) with N being the length in bytes of the script body.
 */
string SCRIPT_LOAD(string script);

/**
 * SDIFF
 *
 * Subtract multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 */
string SDIFF(string key);

/**
 * SDIFFSTORE
 *
 * Subtract multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 */
string SDIFFSTORE(string destination, string key);

/**
 * SELECT
 *
 * Change the selected database for the current connection
 */
string SELECT(string index);

/**
 * SET
 *
 * Set the string value of a key
 *
 * Time complexity: O(1)

 * - Valid values for condition: "NX", "XX"
 */
string SET(string key, string value, string seconds = "", string milliseconds = "", string condition = "");

/**
 * SETBIT
 *
 * Sets or clears the bit at offset in the string value stored at key
 *
 * Time complexity: O(1)
 */
string SETBIT(string key, string offset, string value);

/**
 * SETEX
 *
 * Set the value and expiration of a key
 *
 * Time complexity: O(1)
 */
string SETEX(string key, string seconds, string value);

/**
 * SETNX
 *
 * Set the value of a key, only if the key does not exist
 *
 * Time complexity: O(1)
 */
string SETNX(string key, string value);

/**
 * SETRANGE
 *
 * Overwrite part of a string at key starting at the specified offset
 *
 * Time complexity: O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.
 */
string SETRANGE(string key, string offset, string value);

/**
 * SHUTDOWN
 *
 * Synchronously save the dataset to disk and then shut down the server

 * - Valid values for NOSAVE: "NOSAVE"

 * - Valid values for SAVE: "SAVE"
 */
string SHUTDOWN(string NOSAVE = "", string SAVE = "");

/**
 * SINTER
 *
 * Intersect multiple sets
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
 */
string SINTER(string key);

/**
 * SINTERSTORE
 *
 * Intersect multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.
 */
string SINTERSTORE(string destination, string key);

/**
 * SISMEMBER
 *
 * Determine if a given value is a member of a set
 *
 * Time complexity: O(1)
 */
string SISMEMBER(string key, string member);

/**
 * SLAVEOF
 *
 * Make the server a slave of another instance, or promote it as master
 */
string SLAVEOF(string host, string port);

/**
 * SLOWLOG
 *
 * Manages the Redis slow queries log
 */
string SLOWLOG(string subcommand, string argument = "");

/**
 * SMEMBERS
 *
 * Get all the members in a set
 *
 * Time complexity: O(N) where N is the set cardinality.
 */
string SMEMBERS(string key);

/**
 * SMOVE
 *
 * Move a member from one set to another
 *
 * Time complexity: O(1)
 */
string SMOVE(string source, string destination, string member);

/**
 * SORT
 *
 * Sort the elements in a list, set or sorted set
 *
 * Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is currently O(N) as there is a copy step that will be avoided in next releases.

 * - Valid values for order: "ASC", "DESC"

 * - Valid values for sorting: "ALPHA"
 */
string SORT(string key, string pattern = "", string offset = "", string pattern = "", string order = "", string sorting = "", string destination = "");

/**
 * SPOP
 *
 * Remove and return a random member from a set
 *
 * Time complexity: O(1)
 */
string SPOP(string key);

/**
 * SRANDMEMBER
 *
 * Get one or multiple random members from a set
 *
 * Time complexity: Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count.
 */
string SRANDMEMBER(string key, string count = "");

/**
 * SREM
 *
 * Remove one or more members from a set
 *
 * Time complexity: O(N) where N is the number of members to be removed.
 */
string SREM(string key, string member);

/**
 * STRLEN
 *
 * Get the length of the value stored in a key
 *
 * Time complexity: O(1)
 */
string STRLEN(string key);

/**
 * SUNION
 *
 * Add multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 */
string SUNION(string key);

/**
 * SUNIONSTORE
 *
 * Add multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 */
string SUNIONSTORE(string destination, string key);

/**
 * SYNC
 *
 * Internal command used for replication
 */
string SYNC();

/**
 * TIME
 *
 * Return the current server time
 *
 * Time complexity: O(1)
 */
string TIME();

/**
 * TTL
 *
 * Get the time to live for a key
 *
 * Time complexity: O(1)
 */
string TTL(string key);

/**
 * TYPE
 *
 * Determine the type stored at key
 *
 * Time complexity: O(1)
 */
string TYPE(string key);

/**
 * UNWATCH
 *
 * Forget about all watched keys
 *
 * Time complexity: O(1)
 */
string UNWATCH();

/**
 * WATCH
 *
 * Watch the given keys to determine execution of the MULTI/EXEC block
 *
 * Time complexity: O(1) for every key.
 */
string WATCH(string key);

/**
 * ZADD
 *
 * Add one or more members to a sorted set, or update its score if it already exists
 *
 * Time complexity: O(log(N)) where N is the number of elements in the sorted set.
 */
string ZADD(string key, string score);

/**
 * ZCARD
 *
 * Get the number of members in a sorted set
 *
 * Time complexity: O(1)
 */
string ZCARD(string key);

/**
 * ZCOUNT
 *
 * Count the members in a sorted set with scores within the given values
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M being the number of elements between min and max.
 */
string ZCOUNT(string key, string min, string max);

/**
 * ZINCRBY
 *
 * Increment the score of a member in a sorted set
 *
 * Time complexity: O(log(N)) where N is the number of elements in the sorted set.
 */
string ZINCRBY(string key, string increment, string member);

/**
 * ZINTERSTORE
 *
 * Intersect multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.

 * - Valid values for aggregate: "SUM", "MIN", "MAX"
 */
string ZINTERSTORE(string destination, string numkeys, string key, string weight = "", string aggregate = "");

/**
 * ZRANGE
 *
 * Return a range of members in a sorted set, by index
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 */
string ZRANGE(string key, string start, string stop, string withscores = "");

/**
 * ZRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 */
string ZRANGEBYSCORE(string key, string min, string max, string withscores = "", string offset = "");

/**
 * ZRANK
 *
 * Determine the index of a member in a sorted set
 *
 * Time complexity: O(log(N))
 */
string ZRANK(string key, string member);

/**
 * ZREM
 *
 * Remove one or more members from a sorted set
 *
 * Time complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed.
 */
string ZREM(string key, string member);

/**
 * ZREMRANGEBYRANK
 *
 * Remove all members in a sorted set within the given indexes
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
 */
string ZREMRANGEBYRANK(string key, string start, string stop);

/**
 * ZREMRANGEBYSCORE
 *
 * Remove all members in a sorted set within the given scores
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.
 */
string ZREMRANGEBYSCORE(string key, string min, string max);

/**
 * ZREVRANGE
 *
 * Return a range of members in a sorted set, by index, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 */
string ZREVRANGE(string key, string start, string stop, string withscores = "");

/**
 * ZREVRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 */
string ZREVRANGEBYSCORE(string key, string max, string min, string withscores = "", string offset = "");

/**
 * ZREVRANK
 *
 * Determine the index of a member in a sorted set, with scores ordered from high to low
 *
 * Time complexity: O(log(N))
 */
string ZREVRANK(string key, string member);

/**
 * ZSCORE
 *
 * Get the score associated with the given member in a sorted set
 *
 * Time complexity: O(1)
 */
string ZSCORE(string key, string member);

/**
 * ZUNIONSTORE
 *
 * Add multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.

 * - Valid values for aggregate: "SUM", "MIN", "MAX"
 */
string ZUNIONSTORE(string destination, string numkeys, string key, string weight = "", string aggregate = "");



// Implementation below
string APPEND(string key, string value) {
  redisPushBinarySafe("APPEND");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  return redisCommand();
}

string AUTH(string password) {
  redisPushBinarySafe("AUTH");
  redisPushBinarySafe((password));
  return redisCommand();
}

string BGREWRITEAOF() {
  redisPushBinarySafe("BGREWRITEAOF");
  return redisCommand();
}

string BGSAVE() {
  redisPushBinarySafe("BGSAVE");
  return redisCommand();
}

string BITCOUNT(string key, string start = "", string end = "") {
  redisPushBinarySafe("BITCOUNT");
  redisPushBinarySafe((key));
  if (start != "") redisPushBinarySafe((start));
  if (end != "") redisPushBinarySafe((end));
  return redisCommand();
}

string BITOP(string operation, string destkey, string key) {
  redisPushBinarySafe("BITOP");
  redisPushBinarySafe((operation));
  redisPushBinarySafe((destkey));
  redisPushBinarySafe((key));
  return redisCommand();
}

string BLPOP(string key, string timeout) {
  redisPushBinarySafe("BLPOP");
  redisPushBinarySafe((key));
  redisPushBinarySafe((timeout));
  return redisCommand();
}

string BRPOP(string key, string timeout) {
  redisPushBinarySafe("BRPOP");
  redisPushBinarySafe((key));
  redisPushBinarySafe((timeout));
  return redisCommand();
}

string BRPOPLPUSH(string source, string destination, string timeout) {
  redisPushBinarySafe("BRPOPLPUSH");
  redisPushBinarySafe((source));
  redisPushBinarySafe((destination));
  redisPushBinarySafe((timeout));
  return redisCommand();
}

string CLIENT_KILL(string ip_port) {
  redisPushBinarySafe("CLIENT KILL");
  redisPushBinarySafe((ip_port));
  return redisCommand();
}

string CLIENT_LIST() {
  redisPushBinarySafe("CLIENT LIST");
  return redisCommand();
}

string CLIENT_GETNAME() {
  redisPushBinarySafe("CLIENT GETNAME");
  return redisCommand();
}

string CLIENT_SETNAME(string connection_name) {
  redisPushBinarySafe("CLIENT SETNAME");
  redisPushBinarySafe((connection_name));
  return redisCommand();
}

string CONFIG_GET(string parameter) {
  redisPushBinarySafe("CONFIG GET");
  redisPushBinarySafe((parameter));
  return redisCommand();
}

string CONFIG_SET(string parameter, string value) {
  redisPushBinarySafe("CONFIG SET");
  redisPushBinarySafe((parameter));
  redisPushBinarySafe((value));
  return redisCommand();
}

string CONFIG_RESETSTAT() {
  redisPushBinarySafe("CONFIG RESETSTAT");
  return redisCommand();
}

string DBSIZE() {
  redisPushBinarySafe("DBSIZE");
  return redisCommand();
}

string DEBUG_OBJECT(string key) {
  redisPushBinarySafe("DEBUG OBJECT");
  redisPushBinarySafe((key));
  return redisCommand();
}

string DEBUG_SEGFAULT() {
  redisPushBinarySafe("DEBUG SEGFAULT");
  return redisCommand();
}

string DECR(string key) {
  redisPushBinarySafe("DECR");
  redisPushBinarySafe((key));
  return redisCommand();
}

string DECRBY(string key, string decrement) {
  redisPushBinarySafe("DECRBY");
  redisPushBinarySafe((key));
  redisPushBinarySafe((decrement));
  return redisCommand();
}

string DEL(string key) {
  redisPushBinarySafe("DEL");
  redisPushBinarySafe((key));
  return redisCommand();
}

string DISCARD() {
  redisPushBinarySafe("DISCARD");
  return redisCommand();
}

string DUMP(string key) {
  redisPushBinarySafe("DUMP");
  redisPushBinarySafe((key));
  return redisCommand();
}

string ECHO(string message) {
  redisPushBinarySafe("ECHO");
  redisPushBinarySafe((message));
  return redisCommand();
}

string EVAL(string script, string numkeys, string key, string arg) {
  redisPushBinarySafe("EVAL");
  redisPushBinarySafe((script));
  redisPushBinarySafe((numkeys));
  redisPushBinarySafe((key));
  redisPushBinarySafe((arg));
  return redisCommand();
}

string EVALSHA(string sha1, string numkeys, string key, string arg) {
  redisPushBinarySafe("EVALSHA");
  redisPushBinarySafe((sha1));
  redisPushBinarySafe((numkeys));
  redisPushBinarySafe((key));
  redisPushBinarySafe((arg));
  return redisCommand();
}

string EXEC() {
  redisPushBinarySafe("EXEC");
  return redisCommand();
}

string EXISTS(string key) {
  redisPushBinarySafe("EXISTS");
  redisPushBinarySafe((key));
  return redisCommand();
}

string EXPIRE(string key, string seconds) {
  redisPushBinarySafe("EXPIRE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((seconds));
  return redisCommand();
}

string EXPIREAT(string key, string timestamp) {
  redisPushBinarySafe("EXPIREAT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((timestamp));
  return redisCommand();
}

string FLUSHALL() {
  redisPushBinarySafe("FLUSHALL");
  return redisCommand();
}

string FLUSHDB() {
  redisPushBinarySafe("FLUSHDB");
  return redisCommand();
}

string GET(string key) {
  redisPushBinarySafe("GET");
  redisPushBinarySafe((key));
  return redisCommand();
}

string GETBIT(string key, string offset) {
  redisPushBinarySafe("GETBIT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((offset));
  return redisCommand();
}

string GETRANGE(string key, string start, string end) {
  redisPushBinarySafe("GETRANGE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((start));
  redisPushBinarySafe((end));
  return redisCommand();
}

string GETSET(string key, string value) {
  redisPushBinarySafe("GETSET");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  return redisCommand();
}

string HDEL(string key, string field) {
  redisPushBinarySafe("HDEL");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  return redisCommand();
}

string HEXISTS(string key, string field) {
  redisPushBinarySafe("HEXISTS");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  return redisCommand();
}

string HGET(string key, string field) {
  redisPushBinarySafe("HGET");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  return redisCommand();
}

string HGETALL(string key) {
  redisPushBinarySafe("HGETALL");
  redisPushBinarySafe((key));
  return redisCommand();
}

string HINCRBY(string key, string field, string increment) {
  redisPushBinarySafe("HINCRBY");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  redisPushBinarySafe((increment));
  return redisCommand();
}

string HINCRBYFLOAT(string key, string field, string increment) {
  redisPushBinarySafe("HINCRBYFLOAT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  redisPushBinarySafe((increment));
  return redisCommand();
}

string HKEYS(string key) {
  redisPushBinarySafe("HKEYS");
  redisPushBinarySafe((key));
  return redisCommand();
}

string HLEN(string key) {
  redisPushBinarySafe("HLEN");
  redisPushBinarySafe((key));
  return redisCommand();
}

string HMGET(string key, string field) {
  redisPushBinarySafe("HMGET");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  return redisCommand();
}

string HMSET(string key, string field) {
  redisPushBinarySafe("HMSET");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  return redisCommand();
}

string HSET(string key, string field, string value) {
  redisPushBinarySafe("HSET");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  redisPushBinarySafe((value));
  return redisCommand();
}

string HSETNX(string key, string field, string value) {
  redisPushBinarySafe("HSETNX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((field));
  redisPushBinarySafe((value));
  return redisCommand();
}

string HVALS(string key) {
  redisPushBinarySafe("HVALS");
  redisPushBinarySafe((key));
  return redisCommand();
}

string INCR(string key) {
  redisPushBinarySafe("INCR");
  redisPushBinarySafe((key));
  return redisCommand();
}

string INCRBY(string key, string increment) {
  redisPushBinarySafe("INCRBY");
  redisPushBinarySafe((key));
  redisPushBinarySafe((increment));
  return redisCommand();
}

string INCRBYFLOAT(string key, string increment) {
  redisPushBinarySafe("INCRBYFLOAT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((increment));
  return redisCommand();
}

string INFO(string section = "") {
  redisPushBinarySafe("INFO");
  if (section != "") redisPushBinarySafe((section));
  return redisCommand();
}

string KEYS(string pattern) {
  redisPushBinarySafe("KEYS");
  redisPushBinarySafe((pattern));
  return redisCommand();
}

string LASTSAVE() {
  redisPushBinarySafe("LASTSAVE");
  return redisCommand();
}

string LINDEX(string key, string index) {
  redisPushBinarySafe("LINDEX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((index));
  return redisCommand();
}

string LINSERT(string key, string where, string pivot, string value) {
  redisPushBinarySafe("LINSERT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((where));
  redisPushBinarySafe((pivot));
  redisPushBinarySafe((value));
  return redisCommand();
}

string LLEN(string key) {
  redisPushBinarySafe("LLEN");
  redisPushBinarySafe((key));
  return redisCommand();
}

string LPOP(string key) {
  redisPushBinarySafe("LPOP");
  redisPushBinarySafe((key));
  return redisCommand();
}

string LPUSH(string key, string value) {
  redisPushBinarySafe("LPUSH");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  return redisCommand();
}

string LPUSHX(string key, string value) {
  redisPushBinarySafe("LPUSHX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  return redisCommand();
}

string LRANGE(string key, string start, string stop) {
  redisPushBinarySafe("LRANGE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((start));
  redisPushBinarySafe((stop));
  return redisCommand();
}

string LREM(string key, string count, string value) {
  redisPushBinarySafe("LREM");
  redisPushBinarySafe((key));
  redisPushBinarySafe((count));
  redisPushBinarySafe((value));
  return redisCommand();
}

string LSET(string key, string index, string value) {
  redisPushBinarySafe("LSET");
  redisPushBinarySafe((key));
  redisPushBinarySafe((index));
  redisPushBinarySafe((value));
  return redisCommand();
}

string LTRIM(string key, string start, string stop) {
  redisPushBinarySafe("LTRIM");
  redisPushBinarySafe((key));
  redisPushBinarySafe((start));
  redisPushBinarySafe((stop));
  return redisCommand();
}

string MGET(string key) {
  redisPushBinarySafe("MGET");
  redisPushBinarySafe((key));
  return redisCommand();
}

string MIGRATE(string host, string port, string key, string destination_db, string timeout) {
  redisPushBinarySafe("MIGRATE");
  redisPushBinarySafe((host));
  redisPushBinarySafe((port));
  redisPushBinarySafe((key));
  redisPushBinarySafe((destination_db));
  redisPushBinarySafe((timeout));
  return redisCommand();
}

string MONITOR() {
  redisPushBinarySafe("MONITOR");
  return redisCommand();
}

string MOVE(string key, string db) {
  redisPushBinarySafe("MOVE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((db));
  return redisCommand();
}

string MSET(string key) {
  redisPushBinarySafe("MSET");
  redisPushBinarySafe((key));
  return redisCommand();
}

string MSETNX(string key) {
  redisPushBinarySafe("MSETNX");
  redisPushBinarySafe((key));
  return redisCommand();
}

string MULTI() {
  redisPushBinarySafe("MULTI");
  return redisCommand();
}

string OBJECT(string subcommand, string arguments = "") {
  redisPushBinarySafe("OBJECT");
  redisPushBinarySafe((subcommand));
  if (arguments != "") redisPushBinarySafe((arguments));
  return redisCommand();
}

string PERSIST(string key) {
  redisPushBinarySafe("PERSIST");
  redisPushBinarySafe((key));
  return redisCommand();
}

string PEXPIRE(string key, string milliseconds) {
  redisPushBinarySafe("PEXPIRE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((milliseconds));
  return redisCommand();
}

string PEXPIREAT(string key, string milliseconds_timestamp) {
  redisPushBinarySafe("PEXPIREAT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((milliseconds_timestamp));
  return redisCommand();
}

string PING() {
  redisPushBinarySafe("PING");
  return redisCommand();
}

string PSETEX(string key, string milliseconds, string value) {
  redisPushBinarySafe("PSETEX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((milliseconds));
  redisPushBinarySafe((value));
  return redisCommand();
}

string PTTL(string key) {
  redisPushBinarySafe("PTTL");
  redisPushBinarySafe((key));
  return redisCommand();
}

string PUBLISH(string channel, string message) {
  redisPushBinarySafe("PUBLISH");
  redisPushBinarySafe((channel));
  redisPushBinarySafe((message));
  return redisCommand();
}

string QUIT() {
  redisPushBinarySafe("QUIT");
  return redisCommand();
}

string RANDOMKEY() {
  redisPushBinarySafe("RANDOMKEY");
  return redisCommand();
}

string RENAME(string key, string newkey) {
  redisPushBinarySafe("RENAME");
  redisPushBinarySafe((key));
  redisPushBinarySafe((newkey));
  return redisCommand();
}

string RENAMENX(string key, string newkey) {
  redisPushBinarySafe("RENAMENX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((newkey));
  return redisCommand();
}

string RESTORE(string key, string ttl, string serialized_value) {
  redisPushBinarySafe("RESTORE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((ttl));
  redisPushBinarySafe((serialized_value));
  return redisCommand();
}

string RPOP(string key) {
  redisPushBinarySafe("RPOP");
  redisPushBinarySafe((key));
  return redisCommand();
}

string RPOPLPUSH(string source, string destination) {
  redisPushBinarySafe("RPOPLPUSH");
  redisPushBinarySafe((source));
  redisPushBinarySafe((destination));
  return redisCommand();
}

string RPUSH(string key, string value) {
  redisPushBinarySafe("RPUSH");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  return redisCommand();
}

string RPUSHX(string key, string value) {
  redisPushBinarySafe("RPUSHX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  return redisCommand();
}

string SADD(string key, string member) {
  redisPushBinarySafe("SADD");
  redisPushBinarySafe((key));
  redisPushBinarySafe((member));
  return redisCommand();
}

string SAVE() {
  redisPushBinarySafe("SAVE");
  return redisCommand();
}

string SCARD(string key) {
  redisPushBinarySafe("SCARD");
  redisPushBinarySafe((key));
  return redisCommand();
}

string SCRIPT_EXISTS(string script) {
  redisPushBinarySafe("SCRIPT EXISTS");
  redisPushBinarySafe((script));
  return redisCommand();
}

string SCRIPT_FLUSH() {
  redisPushBinarySafe("SCRIPT FLUSH");
  return redisCommand();
}

string SCRIPT_KILL() {
  redisPushBinarySafe("SCRIPT KILL");
  return redisCommand();
}

string SCRIPT_LOAD(string script) {
  redisPushBinarySafe("SCRIPT LOAD");
  redisPushBinarySafe((script));
  return redisCommand();
}

string SDIFF(string key) {
  redisPushBinarySafe("SDIFF");
  redisPushBinarySafe((key));
  return redisCommand();
}

string SDIFFSTORE(string destination, string key) {
  redisPushBinarySafe("SDIFFSTORE");
  redisPushBinarySafe((destination));
  redisPushBinarySafe((key));
  return redisCommand();
}

string SELECT(string index) {
  redisPushBinarySafe("SELECT");
  redisPushBinarySafe((index));
  return redisCommand();
}

string SET(string key, string value, string seconds = "", string milliseconds = "", string condition = "") {
  redisPushBinarySafe("SET");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  if (seconds != "") redisPushBinarySafe((seconds));
  if (milliseconds != "") redisPushBinarySafe((milliseconds));
  if (condition != "") redisPushBinarySafe((condition));
  return redisCommand();
}

string SETBIT(string key, string offset, string value) {
  redisPushBinarySafe("SETBIT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((offset));
  redisPushBinarySafe((value));
  return redisCommand();
}

string SETEX(string key, string seconds, string value) {
  redisPushBinarySafe("SETEX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((seconds));
  redisPushBinarySafe((value));
  return redisCommand();
}

string SETNX(string key, string value) {
  redisPushBinarySafe("SETNX");
  redisPushBinarySafe((key));
  redisPushBinarySafe((value));
  return redisCommand();
}

string SETRANGE(string key, string offset, string value) {
  redisPushBinarySafe("SETRANGE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((offset));
  redisPushBinarySafe((value));
  return redisCommand();
}

string SHUTDOWN(string NOSAVE = "", string SAVE = "") {
  redisPushBinarySafe("SHUTDOWN");
  if (NOSAVE != "") redisPushBinarySafe((NOSAVE));
  if (SAVE != "") redisPushBinarySafe((SAVE));
  return redisCommand();
}

string SINTER(string key) {
  redisPushBinarySafe("SINTER");
  redisPushBinarySafe((key));
  return redisCommand();
}

string SINTERSTORE(string destination, string key) {
  redisPushBinarySafe("SINTERSTORE");
  redisPushBinarySafe((destination));
  redisPushBinarySafe((key));
  return redisCommand();
}

string SISMEMBER(string key, string member) {
  redisPushBinarySafe("SISMEMBER");
  redisPushBinarySafe((key));
  redisPushBinarySafe((member));
  return redisCommand();
}

string SLAVEOF(string host, string port) {
  redisPushBinarySafe("SLAVEOF");
  redisPushBinarySafe((host));
  redisPushBinarySafe((port));
  return redisCommand();
}

string SLOWLOG(string subcommand, string argument = "") {
  redisPushBinarySafe("SLOWLOG");
  redisPushBinarySafe((subcommand));
  if (argument != "") redisPushBinarySafe((argument));
  return redisCommand();
}

string SMEMBERS(string key) {
  redisPushBinarySafe("SMEMBERS");
  redisPushBinarySafe((key));
  return redisCommand();
}

string SMOVE(string source, string destination, string member) {
  redisPushBinarySafe("SMOVE");
  redisPushBinarySafe((source));
  redisPushBinarySafe((destination));
  redisPushBinarySafe((member));
  return redisCommand();
}

string SORT(string key, string pattern = "", string offset = "", string pattern = "", string order = "", string sorting = "", string destination = "") {
  redisPushBinarySafe("SORT");
  redisPushBinarySafe((key));
  if (pattern != "") redisPushBinarySafe((pattern));
  if (offset != "") redisPushBinarySafe((offset));
  if (pattern != "") redisPushBinarySafe((pattern));
  if (order != "") redisPushBinarySafe((order));
  if (sorting != "") redisPushBinarySafe((sorting));
  if (destination != "") redisPushBinarySafe((destination));
  return redisCommand();
}

string SPOP(string key) {
  redisPushBinarySafe("SPOP");
  redisPushBinarySafe((key));
  return redisCommand();
}

string SRANDMEMBER(string key, string count = "") {
  redisPushBinarySafe("SRANDMEMBER");
  redisPushBinarySafe((key));
  if (count != "") redisPushBinarySafe((count));
  return redisCommand();
}

string SREM(string key, string member) {
  redisPushBinarySafe("SREM");
  redisPushBinarySafe((key));
  redisPushBinarySafe((member));
  return redisCommand();
}

string STRLEN(string key) {
  redisPushBinarySafe("STRLEN");
  redisPushBinarySafe((key));
  return redisCommand();
}

string SUNION(string key) {
  redisPushBinarySafe("SUNION");
  redisPushBinarySafe((key));
  return redisCommand();
}

string SUNIONSTORE(string destination, string key) {
  redisPushBinarySafe("SUNIONSTORE");
  redisPushBinarySafe((destination));
  redisPushBinarySafe((key));
  return redisCommand();
}

string SYNC() {
  redisPushBinarySafe("SYNC");
  return redisCommand();
}

string TIME() {
  redisPushBinarySafe("TIME");
  return redisCommand();
}

string TTL(string key) {
  redisPushBinarySafe("TTL");
  redisPushBinarySafe((key));
  return redisCommand();
}

string TYPE(string key) {
  redisPushBinarySafe("TYPE");
  redisPushBinarySafe((key));
  return redisCommand();
}

string UNWATCH() {
  redisPushBinarySafe("UNWATCH");
  return redisCommand();
}

string WATCH(string key) {
  redisPushBinarySafe("WATCH");
  redisPushBinarySafe((key));
  return redisCommand();
}

string ZADD(string key, string score) {
  redisPushBinarySafe("ZADD");
  redisPushBinarySafe((key));
  redisPushBinarySafe((score));
  return redisCommand();
}

string ZCARD(string key) {
  redisPushBinarySafe("ZCARD");
  redisPushBinarySafe((key));
  return redisCommand();
}

string ZCOUNT(string key, string min, string max) {
  redisPushBinarySafe("ZCOUNT");
  redisPushBinarySafe((key));
  redisPushBinarySafe((min));
  redisPushBinarySafe((max));
  return redisCommand();
}

string ZINCRBY(string key, string increment, string member) {
  redisPushBinarySafe("ZINCRBY");
  redisPushBinarySafe((key));
  redisPushBinarySafe((increment));
  redisPushBinarySafe((member));
  return redisCommand();
}

string ZINTERSTORE(string destination, string numkeys, string key, string weight = "", string aggregate = "") {
  redisPushBinarySafe("ZINTERSTORE");
  redisPushBinarySafe((destination));
  redisPushBinarySafe((numkeys));
  redisPushBinarySafe((key));
  if (weight != "") redisPushBinarySafe((weight));
  if (aggregate != "") redisPushBinarySafe((aggregate));
  return redisCommand();
}

string ZRANGE(string key, string start, string stop, string withscores = "") {
  redisPushBinarySafe("ZRANGE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((start));
  redisPushBinarySafe((stop));
  if (withscores != "") redisPushBinarySafe((withscores));
  return redisCommand();
}

string ZRANGEBYSCORE(string key, string min, string max, string withscores = "", string offset = "") {
  redisPushBinarySafe("ZRANGEBYSCORE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((min));
  redisPushBinarySafe((max));
  if (withscores != "") redisPushBinarySafe((withscores));
  if (offset != "") redisPushBinarySafe((offset));
  return redisCommand();
}

string ZRANK(string key, string member) {
  redisPushBinarySafe("ZRANK");
  redisPushBinarySafe((key));
  redisPushBinarySafe((member));
  return redisCommand();
}

string ZREM(string key, string member) {
  redisPushBinarySafe("ZREM");
  redisPushBinarySafe((key));
  redisPushBinarySafe((member));
  return redisCommand();
}

string ZREMRANGEBYRANK(string key, string start, string stop) {
  redisPushBinarySafe("ZREMRANGEBYRANK");
  redisPushBinarySafe((key));
  redisPushBinarySafe((start));
  redisPushBinarySafe((stop));
  return redisCommand();
}

string ZREMRANGEBYSCORE(string key, string min, string max) {
  redisPushBinarySafe("ZREMRANGEBYSCORE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((min));
  redisPushBinarySafe((max));
  return redisCommand();
}

string ZREVRANGE(string key, string start, string stop, string withscores = "") {
  redisPushBinarySafe("ZREVRANGE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((start));
  redisPushBinarySafe((stop));
  if (withscores != "") redisPushBinarySafe((withscores));
  return redisCommand();
}

string ZREVRANGEBYSCORE(string key, string max, string min, string withscores = "", string offset = "") {
  redisPushBinarySafe("ZREVRANGEBYSCORE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((max));
  redisPushBinarySafe((min));
  if (withscores != "") redisPushBinarySafe((withscores));
  if (offset != "") redisPushBinarySafe((offset));
  return redisCommand();
}

string ZREVRANK(string key, string member) {
  redisPushBinarySafe("ZREVRANK");
  redisPushBinarySafe((key));
  redisPushBinarySafe((member));
  return redisCommand();
}

string ZSCORE(string key, string member) {
  redisPushBinarySafe("ZSCORE");
  redisPushBinarySafe((key));
  redisPushBinarySafe((member));
  return redisCommand();
}

string ZUNIONSTORE(string destination, string numkeys, string key, string weight = "", string aggregate = "") {
  redisPushBinarySafe("ZUNIONSTORE");
  redisPushBinarySafe((destination));
  redisPushBinarySafe((numkeys));
  redisPushBinarySafe((key));
  if (weight != "") redisPushBinarySafe((weight));
  if (aggregate != "") redisPushBinarySafe((aggregate));
  return redisCommand();
}
