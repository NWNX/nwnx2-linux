require 'json'
require 'pp'

template = "%s %s("

json = JSON.parse(IO.read("commands.json"))

def type_to_nwn type
	case type
		when "key", "string", "posix time", "pattern", "enum"
			"string"
		when "integer"
			#int
			"string"
		when "double"
			#"float"
			"string"
		else
			fail "Unknown type: #{type}"
		end
end

def name_to_nwn name
	name.gsub(/[^a-zA-Z0-9_]/, "_")
end

failed = []

json = json.map do |cmd, c|
	args = []

  # Don't export pubsub commands because they will just break the command
  # connection with no way to receive those events.
  next if %w{
    SUBSCRIBE PSUBSCRIBE UNSUBSCRIBE PUNSUBSCRIBE
  }.index(cmd)

	if c['arguments']
		args = c['arguments'].map do |h|
			# For now, multiple arguments are just coalesced into one.
			names = [h['name']].flatten
			types = [h['type']].flatten

			names = names.map do| n| name_to_nwn n end
			types = types.map do |n| type_to_nwn n end

			types.map {|t| [t, names[types.index(t)], h['enum'], h['optional']] }.flatten(1)


			#[type_to_nwn(h['type']), h['name']].join(" ")
		end rescue begin
			failed << "Skipping #{cmd} due to: #{$!}"
			next
		end
	end

	funame = cmd.gsub(" ", "_")

	body = ""
	body += "  redisPushBinarySafe(\"%s\");\n" % cmd
	args.each do |aa|
		body += "  "
		body += "if (%s != \"\") " % [aa[1]] if aa[3]
		body += "redisPushBinarySafe(%s(%s));\n" % [case aa[0]
			when "int"
				"IntToString"
			when "float"
				"FloatToString"
			when "string"
				""
			else
				fail "#{aa[0]} not a valid type"
		end, aa[1]]
	end
	body += "  return redisCommand();"


	argdef = args.map{|a|
		v = "%s %s" % [a[0], a[1]]
		v << " = \"\"" if a[3]
		v
	}.join(", ")

	impl = "string %s(%s) {\n" % [funame, argdef]
	impl += "%s\n" % body
	impl += "}\n"

	head  = "/**\n"
	head += " * %s\n" % cmd
	head += " *\n * %s\n" % c['summary'] if c['summary']
	head += " *\n * Time complexity: %s\n" % c['complexity'] if c['complexity']

	args.each do |a|
		next unless a[2]
		head += "\n * - Valid values for %s: %s\n" % [a[1], a[2].map{|v| v.inspect}.join(", ")]
	end

	head += " */\n"
	head += "string %s(%s);" % [funame, argdef]

	{
		:head => head,
		:impl => impl,
	}
end.compact

puts "// Autogenerated on: #{Time.now}"
puts "#include \"nwnx_redis_core\"\n\n"

failed.each do |fail|
	puts "// " + fail
end

json.each do |ha|
	puts ha[:head]
	puts ""
end

puts "\n\n// Implementation below\n"

json.each do |ha|
	puts ha[:impl]
	puts ""
end
